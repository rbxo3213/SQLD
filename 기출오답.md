# 1회

2. ERD관계에서, 점선/실선 여부, 주식별자 찾기, 까마귀발, 선택/필수 여부 를 찾고 문제를 풀자.

3. 대체 여부에 따라 분류한 식별자 중,

   - 업무에 의해 만들어 진 것: 원조(본질) 식별자
   - 업무에 의해 만들어지지는 않았으나 필요에 따라 인위적으로 만든 것: 인조 식별자

4. NULLIF(A,B): A와 B가 같으면 NULL, 아니면 A를 출력.

   - IFNULL(A,B): A가 NULL이면 B값 출력, NVL의 MSSQL문법 버전.

5. MINUS/EXCEPT, INTERSECT, UNION 은, 연산 결과에서 중복을 제거한다고 생각하자.

   - 1,2,2,3 MINUS 3 -> 하면 1,2,2로 잘못 헷갈릴 수 있다. 중복도 제거해야 하므로 1,2가 된다.

6. 파티션 내 비율 -> RATIO_TO_REPORT

7. GROUP BY 부서 -> 이러면 부서 컬럼 값은 1개씩만 나오게 된다. 즉 중복되는 부서 컬럼값이 없어진다는 뜻.

8. SUBSTR에 길이 지정 안하면 그냥 끝까지 감.

9. ROUND함수에서, 1, 2 -> 이건 소숫점 첫째자리까지, 둘째자리까지 이거지만, 0일때는 소숫점을 아예 없게 함.

   - 즉, -1은 1의 자리까지가 아니라, 0이 1의자리까지 반올림이고, -1은 10의자리까지, -2는 100의자리까지 반올림.
   - 그리고 ROUND는 반올림 임을 명심하자. ROUND(3.45)일때, 3.45의 4는 5보다 작기 때문에, 결과는 3이된다.

10. _[진짜진짜주의]_ NOT IN 절 내에는 NULL이 들어가면 안 된다. 들어가게 되면 NOT IN은 AND 연산을 하기때문에, = NULL 비교를 하게되어 FALSE, 결과데이터가 없게 된다.

    - IN 절에는 NULL이 들어가도 부분적으로 괜찮다. IN은 OR연산이기 때문에, 그러나 COL1:NULL,1,2 일때 WHERE (1,2,NULL) IN COL 하면,
    - NULL이 있기때문에 NULL을 출력할 것 같지만, = NULL 비교이기 때문에 FALSE, 즉 1,2에 해당하는 결과만 출력한다.
    - 꼭 주의할것!!

11. CHECK 제약조건은 참조 무결성 제약조건에 대한 것이 아니라, 컬럼에 입력할 수 있는 값의 범위를 제한하는 것이다.

12. 계층형 쿼리 내장함수 추가: CONNECT_BY_ISCYCLE, NOCYCLE. ---> BLEVEL은 어디서 온거?? 이런건 없다.

13. COUNT(1), COUNT(2)와 같이 COUNT내에 상수값 입력 시 COUNT(\*)와 같이 모든 행의 수를 출력한다.

# 2회

1. 특정 컬럼만 빈번하게 사용되어 반정규화를 하려고 한다~~ -> 수직 분할
2. 영속적으로 존재하는 인스턴스의 집합 --> 엔터티에 대한 설명이다.

3. 어째서인지 프로젝트는 중심엔터티라 한다.. 독립적으로 생성이 불가능한가보다.. 어떤 기본엔터티로부터 생성되지?

```SQL
4.
SELECT S.학번, MAX(S.이름)
FROM STUDENT S, ENROLL E
WHERE S.학번 = E.학번
GROUP BY S.학번
HAVING AVG(E.학점) >= 3.0;

MAX(S.이름) <- 무슨 뜻?
```

5. WHERE 1=2, WHERE 2=3 등의 표현은 항상 FALSE를 반환하여 아무 데이터도 출력하지 않게 한다. COUNT(\*)와 사용할 때, 0을 출력함

6. 계층함수에서, 트리를 먼저 만든 다음에 WHERE을 적용한다. WHERE COL3 <> 2 이렇게 되있을 때 트리를 연결할때는 아무 영향 X

   - START WITH 절 부터 시작한다.

7. NATURAL JOIN은 USING 절과 함께 사용할 수 없다. USING 절은 JOIN에서 사용

8. 연산자 우선순위 : 괄호, 산술, 연결, 비교, (IN LIKE BETWEEN IS NULL), NOT, AND, OR

   - 괄 산연비 연비야 어디를 가느냐

9. NVL2 -> 어? 오라클 특징인 2붙이는 건가? 할 수 있는데, NVL2은 NVL과 다르게 인수가 3개여야 함.

10. COALESCE(NULL, NULL) -> NULL이 출력됨.

    - DECODE('X','Y','Z',NULL) -> 기준값 X가 Y와 같으면 Z출력, ELSE로 NULL출력.

11. COL1 IN('SQL') 이때 COL1이 ('SQL','sql') 일때, 대소문자를 구분한다.. 어디선 하고 어디선 안 하고 에휴 아무튼 'SQL'일치결과만 반환

12. Oracle에선 NULL을 최댓값 취급. DESC하면 맨 위에 오게 되는데, NULLS LAST를 사용해서 NULL값을 맨 밑으로 위치 지정할 수 있음.

# 3회

1. CROSS JOIN은 집합 연산자의 PRODUCT 개념. 카테시안 곱으로 별도의 ON 절이 없다.
2. SELECT 구문에 사용되지 않은 컬럼도 ORDER BY 구문에 사용할 수 있다.
3. COL1 PRIMARY KEY, COL2, COL3 일때, INSERT TABLE (COL2, COL3) VALUES (값1, 값2) 할 수 없다 왜냐하면 COL1은 PRIMARY KEY여서 필수로 입력해야 하기 때문이다.
