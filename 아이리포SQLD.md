1. 관계연결을 가능하게 하는 '동사'로부터는 관계를, '명사'로부터는 엔터티를 도출한다.
2. 계좌번호와 고객번호가 복합 PK일때, 계좌번호는 고객별로는 유일하나 전체고객에 대해서는 유일하다 할 수 없다.
3. 정규화가 항상 조회 성능을 떨어트리는 것은 아니다. 또한 반정규화는 잘 되어있는 정규화를 전제로 한다.
4. 논리적 데이터 모델링에서 엔터티, 물리적 데이터 모델링에선 테이블, 관계형DB에선 릴레이션 이라 함.
5. 성능 데이터 모델링 과정
   - 정규화, 용량산정, 트랜잭션 유형 파악, 반정규화, (이력모델, PFK, 슈퍼/서브타입 조정), 데이터모델 검증
   - 정 용 트 반 이P슈 검
6. 반정규화 과정: 대상 조사 - 다른 방법 검토 - 반정규화 적용
7. 슈퍼/서브타입 관계 테이블 병합 종류
   - ONE TO ONE, PLUS, SINGLE(O P S -> 원피스)
   - ONE TO ONE: 슈퍼타입, 서브타입 테이블들을 각각 개별 테이블로 구성
   - PLUS: 각각의 서브타입에 슈퍼타입을 합하여 슈퍼타입+서브타입 테이블로 구성
   - SINGLE: 전체를 하나의 테이블로 통합
8. 반정규화
   - 조인 잦을때 병합
   - 특정 컬럼 집중접근시, 또는 로우체이닝 발생 시 -> 수직분할하여 1:1관계로
   - 속성의 값(연도 별)에 따라 구분하여 조회하는 경우 수평분할(파티셔닝)
9. 관계 반정규화: 여러 단계를 거쳐 다수의 조인을 통해 처리가 가능하나 이때 발생하는 부하를 막기 위해 추가적으로 중복된 관계를 맺는 방법
10. 인조식별자: 주문목록의 PK인 주문번호, 도서번호를 주문목록번호로 묶고 원래 두개는 일반속성으로.

    - 추가적인 연산없이 주식별자 생성 가능, 편의성 증대 BUT 데이터 중복 발생 가능성, 별도의 인덱스 생성 필요

11. 제 3정규화는 일반 속성 사이의 함수종속성이 존재하는 이행함수종속을 제거하는 것으로 주식별자와 관련성이 없다.

12. 성능저하 문제 발생시 문제발생 시점의 SQL보다는 데이터모델을 중심으로(우선) 튜닝
13. 관계의 반정규화는 데이터 무결성을 깨뜨리지 않는다.
14. MERGE는 DML(SELECT, INSERT,,)이다.
15. 55/0은 NULL반환이 아니라 에러를 발생시킨다. NULL을 대상으로 한 산술연산 결과는 모두 NULL이다. NULL+5, NULL\*NULL 등..
16. MOD(21,0) -> 21%0 -> 21을 반환함. MOD(-5,-3) -> -2를 반환함.
17. 조인의 대상인 두 테이블은 스키마가 같지 않아도 기준이 되는 키를 공유하고 있으면 조인 가능하다

    - 스키마: 테이블의 컬럼명(이름, 주소,...)

18. COL1: 번호, 이름, 성별, 연봉 // COL2: 번호, 직업, 연봉
    - NATURAL JOIN시, 번호와 연봉 값이 같은 행을 조인.
    - 결과로 번호, 연봉, 이름, 성별, 직업
19. 인라인뷰를 사용하면 ALIAS를 통해 전체적으로 코드의 가독성이 높아진다고 함..
20. 집합연산자는 두 테이블의 칼럼 구성 즉 스키마가 동일해야 한다. 반환되는 컬럼명은 첫 테이블을 따른다.
21. ROWNUM을 ORDER BY와 함께 사용하면 뒤죽박죽 된다. 왜냐면 ORDER BY가 젤 마지막에 수행되기 때문에.
    - 정렬후 번호를 매기고 싶은거라면 ROW_NUMBER()를 사용하자
22. 계층 쿼리 순방향 전개: 프-자-부 ㅋㅋ
    - 역방향은 프-부-자(자-프-부)
23. CASCADE에 의해 자식 값이 삭제될 때 칼럼의 값만 삭제되는 것이 아니라 행 전체가 삭제됨. 칼럼의 값만 삭제하고 싶으면 SET NULL 제약조건을 설정
24. TRUNCATE: 테이블의 데이터를 전부 삭제, 스키마는 그대로 둔다(재사용 가능), DELETE와 달리 롤백이 불가능하고 저장 공간이 릴리즈 된다.
25. 참조 무결성 제약조건 INSERT
    - AUTOMATIC: 부모 테이블에 PK가 없는 경우 PK 생성 후 자식 테이블에 값이 입력된다.
    - DEPENDENT: KF선언 시 부모 테이블에 PK가 없는 경우 자식 테이블에 데이터 입력을 허용하지 않음
26. SQL SERVER에선 ALTER의 MODIFY가 ALTER로 정의. 또한 Oracle과 달리 여러 컬럼을 한 번에 수정 불가. 각각의 쿼리 작성해야함.

27. Oracle의 CTAS -> SQR SERVER 에선 SELECT \* INTO 새 테이블명 FROM 원본 테이블
    - CTAS: CREATE TABLE 새 테이블 AS SELECT \* FROM 원래 테이블;
    - 기존 테이블에서 새 테이블로 데이터를 복사하는 CTAS

# PIVOT절, UNPIVOT 절

- PIVOT은 함수가 아니라 구문으로 PIVOT절이라 하며, FROM절 뒤에 온다.
- E.NO=D.NO 조인 해주고, PIVOT (COUNT(\*) FOR DNAME IN ('컬럼값1'AS 컬럼명, '컬럼값2' AS 컬럼명2,...));
  -> 행을 컬럼명으로 바꿔줌, 원-핫 인코딩 느낌으로 됨..

- UNPIVOT절: PIVOT과 반대로 열을 행으로 바꾼다. 스키마들이 한 컬럼의 컬럼값이 되고 이에 맞게 재배치 됨.
  - UNPIVOT (기온 FOR 연도 IN (컬럼명 AS '컬럼값', 컬럼명2 AS '컬럼값2',...))

# 정규 표현식

1. ^THE: THE로 시작하는 문자열
2. ING$: ING으로 끝나는 문자열
3. A.B: ACB, A-B, A1B,...
4. NO?: N,NO
5. NO\*: N,NO,NOO,... -----> .\*하면 임의의 문자 0개이상 이라는 뜻.
6. NO+: NO,NOO,NOOO...
7. A|B: A,B
8. [ABC]: A,B,C 중 하나와 일치
9. [A-Z]: A부터 Z까지 대문자 글자, [0-9]: 0부터 9까지
10. [^ABC]: A,B,C를 제외한 나머지 글자, [^0-9]: 0부터 9까지를 제외한 나머지 글자
11. (AB): 소괄호로 묶인 표현식을 한 단위 취급.

- REGEXP_LIKE: 정규표현식 LIKE연산
- REGEXP_REPLACE: 정규표현식 사용하여 문자열 대체
- REGEXP_INSTR: 정규표현식 사용하여 문자열 검색 후 위치 반환
- REGEXP_SUBSTR: 정규표현식 사용하여 부분 문자열 반환
- REGEXP_COUNT: 정규표현식 사용하여 특정 패턴의 문자열 개수 반환

# 4장 오답

- 서브쿼리: 메인쿼리의 컬럼 모두 사용 가능, ORDER BY절 사용 불가능
- 메인쿼리: 서브쿼리의 컬럼을 사용할 수 없음.
- NOT EXISTS-> 헷갈리는데, 그냥 대충 서브쿼리 조건에 맞는건 제외한다 생각하면 됨. EXISTS는 그 반대로 조건에 맞는것만 포함
- !! ROUNUM은 ROWNUM<, <=만 가능. ROWNUM>=10, ROWNUM=10 이런건 불가능(결과 아예 출력 X), ROWNUM<>10 이건 무조건 9번까지만 출력.

5. 계층 쿼리 풀때.. 원래 테이블과 결과 테이블을 한 번 보고, 원래 테이블의 트리를 그려보자.
   - 결과 테이블이 아시아지부, 한국지사, 서울지점, 부산지점 이면, 아시아지부-중국지사는 제외된 것.

# 아이리포 기출 1회

1. WHEN 절에서 가장 위의 조건을 만족하면 그 아래 조건은 체크(수행)하지 않는다. IF~ELSE IF 느낌.
2. OTLP에는 HASH보다 NEST~어쩌구가 더 유리하다
3. WHERE EXISTS(서브쿼리) 이렇게 써야지. -> WHERE 주문일자 EXISTS <- 이런건 없다.

# 기출 2회

1. 중복가능 -> 주식별자로 부적절
2. GROUP BY 는 SELECT절보다 먼저 실행되므로 GROUP BY에 없는 컬럼을 SELECT에 출력하면 값을 특정할 수 없어 출력 불가능

# 기출 3회

1. CHECK 제약조건도 데이터 무결성 유지를 위한 제약이군..
2. AK => 보조식별자
3. 비식별자 관계라고 해서 조인이 최소화되진 않는다!
4. 데이터의 생명주기 -> 식별자 관계가 더 적합함.
5. UNION이나 UNION의 대상, 집합연산자는 서로 스키마(컬럼 수와 데이터 타입)가 같아야 함.
6. ALTER로 데이터타입을 변경하려면 컬럼이 비어있어야 한다. 그러나 DATE를 TIMESTAMP로 변경하는 것에 한해 비어있지 않아도 가능하다.

# 기출 4회

1. 이자는 파생속성이나 이자율은 기본속성이다.
2. 문자열을 TO_DATE로 DATE형으로 변환할 때, 연도는 올해, 월은 이번달, 일은 1일을 기본으로 하여 생성한다.
