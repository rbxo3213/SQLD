1. 데이터 모델링 3요소: Things, Attribute, relationship
2. 관계 체크사항: 관계 연결을 가능하게 하는 '동사'가 있느냐. not 명사
3. 논리 모델링 외래키는 물리 모델에서 반드시 구현되지는 않음.
4. 해시 조인: cpu연산이 큰 조인으로, 선행 테이블 크기가 작아야 유리, 인덱스 없어도 가능, only '=' 동등조인에서만
5. 설계 단계에서 데이터 모델의 성능을 고려하는 절차와 방법

   - 첫 번째 단계로 정규화를 적용한 DB모델 만들기, DB용량 산정, 트랜잭션 유형 파악, 이력모델, 기본키/외래키, 슈퍼타입/서브타입 조정

6. 데이터 모델링이 최종적으로 완료된 상태 즉 물리적 스키마 설계 직전단계는?

   - 논리적 데이터 모델링

7. COMMIT과 ROLLBACK의 장점: 데이터 무결성 보장, 영구적 변경 전 확인 가능, 논리적으로 연관된 작업을 그룹핑하여 처리 가능

8. UNION 연산자는 조회 결과에 대한 합집합을 나타내며 자동으로 정렬을 해준다 오 신기..

9. EQUI 조인은 반드시 기본키, 외래키 관계에 의해서만 성립되는 것은 아니다.

10. 여러 테이블로부터 원하는 데이터를 조회하기 위해서는 최소 전체 테이블 개수 N-1개 만큼의 조인이 필요하다

11. 상호 연관 서브쿼리는 서브 쿼리가 메인 쿼리의 행 마다 실행 -> 실행 속도가 상대적으로 떨어짐.

12. FROM 절에 아무리 많은 테이블이 나열되더라도 2개씩 조인됨.

13. COUNT(DISTINCT 이름) 이름 컬럼에서 중복 없이 고유한 값의 개수를 세어줍니다.

    - DISTINCT COUNT(이름) -> 여기서 DISTINCT는 아무 쓸모없이 쓰였ㅇㅁ.

14. CASE문 사용법..
    - CASE WHEN A.COL1 IS NULL THEN -1 ELSE 0 END
    - ✅ IS NULL은 NULL 여부를 정확히 판단할 수 있습니다.
      - CASE A.COL1 WHEN NULL THEN -1 ELSE 0 END
      - -- 단순 CASE에서 NULL은 비교가 안 됨 → ❌ 항상 ELSE로 처리됨
15. ORDER BY 절에서, 컬럼 3개에 대해서 내림차순 할 때.

    - 첫 번째 컬럼 내림차순 하고, 첫 번째 컬럼에서 같은 값을 두 번째 컬럼에서 내림차순 하고, 두 번째 컬럼에서 같은 값을 세 번째 컬럼에서 내림차순. 이렇게 함.!!!
      - 그니까 두 번째 컬럼 내림차순 정렬은, 첫 번째 컬럼에서 같았던 값을 가진 행에 대해서만 하면 되는 것!

16. LIKE '%이%' 처럼 양 옆에 %를 붙였을 경우 정상적인 인덱스 범위 스캔이 불가능하다.

17. 그룹 내 행 순서 관련 함수: FIRST_VALUE, LAST_VALUE, LAG, LEAD.

    - RANK는 순위를 구하는 윈도우 함수로 행의 순서와는 관련이 없다.
    - DENSE_RANK는 동일한 순위를 하나의 건수로 취급한다.

18. WHERE ROWNUM = 2 이런 건너뛰기는 안 되지만, WHERE ROWNUM=1 이건 건너뛰기 아니고 첫 행이라서 가능
19. SELECT COUNT(번호) FROM 사원 과 SELECT COUNT(번호) FROM 사원 WHERE 월급>=10000 OR 월급<10000

    - 월급이 NULL일 수 있기 때문에 두 쿼리의 결과는 항상 같지는 않음.

20. 날짜1 - 날짜2 의 결과는 일 수가 나온다
21. NEXT_DAY 함수는 지정된 요일의 첫 번째 날짜를 출력한다.

22. 메인쿼리에서 서브쿼리의 컬럼을 직접 사용할 수 없다.

23. CASE문에서, COL1 WHEN 1 THEN A ELSE B -> WHEN 이전에 컬럼이 오면 동등비교('=')만 가능
    - WHEN COL1 ~~ THEN -> 이런 형식은 >, <, BETWEEN, IS NULL 등 복잡한 비교 가능.
24. ```SQL
    SELECT 'A', 1 FROM DUAL
    UNION ALL
    SELECT 1, 'A' FROM DUAL;
    ```
    - 집합 연산자는 컬럼 타입 순서를 맞춰줘야해서, 이 SQL문은 에러가 난다.

# 1회

1. CONNECT BY는 부모 자식을 설명하는 것이 아니라, 부모 노드와 자식 노드 사이의 특정한 관계를 나타내는데 사용하는 것.
2. GRANT 로 부여한 권한은, 먼저 권한을 할당받은 부모 사용자의 권한이 취소되면 자식 사용자들은 연쇄적으로 전부 취소된다.
3. UNBOUNDED PRECEDING은 첫 행을 가리키기 때문에 BETWEEN절의 END POINT에 사용될 수 없다.
4. DATE 타입. '20230101'같은 문자열은 자동형변환 됨. 20230101 이런 숫자형 값은 데이터타입 불일치 에러가 발생함.
5. 유일성과 최소성을 만족하는 키 -> 후보키.
   - 기본키는 후보키 중에서 엔터티를 대표할 수 있는 키.
   - 슈퍼키는 유일성은 만족하나 최소성을 만족하지 않는 키

# 6회

1. 정규화 목적: 갱신이상 방지, 정보 손실(삭제이상) 방지, 정보 중복 방지. -> 보안은 뷰의 목적
2. SQLD에서 배우는 보통의 ERD구조 -> IE 표기법
3. 집계함수에서 COUNT(\*)는 조건절이 FALSE일때 (WHERE 2=1, WHERE 2=NULL) 0을 반환함.
4. GROUP BY COL1 할때 COL1이 NULL, NULL, 1, 2라면? COUNT(\*)시 NULL : 2, 1 : 1, 2 : 1 이 반환됨. 즉, 당연하지만 NULL도 컬럼값 취급함.
5. SELECT DISTINCT COL1, COL2 FROM TABLE; -> 이 구문은 (COL1, COL2)의 조합이 완전히 동일한 행만 제거합니다.

   - 나는 DISTINCT가 COL1에만 적용되는 줄 알고 헷갈렸었음..

6. 순수 관계 연산자: SELECT, PROJECT, DIVIDE, JOIN
7. 제품마스터-제품생산-주문이력-> 제품마스터와 주문이력을 조인하면 카테시안곱이 발생한다 -> 조인키가 없으면 맞느느 말임.

8. MERGE시에, UPDATE, DELETE순으로 있을 때, 앞의 UPDATE가 이루어진 행에 대해서만 DELETE가 추후로 수행된다.

   - UPDATE가 수행되지 않았으면 DELETE도 수행되지 않는다. 아무튼 그렇다고 한다..
   - MERGE문에서는 WHEN MATCHED THEN 안의 UPDATE와 DELETE의 실행 순서는 코드에 적힌 순서와 상관없이 Oracle 내부적으로는 항상 UPDATE → DELETE 순서로 처리됩니다. 즉 DELETE-UPDATE 순서로 적어도, UPDATE먼저 수행되고, UPDATE가 수행되면 DELETE도 수행하고 하나보다 에휴

9. NATURAL, CROSS 조인-> ON절이 없음.
   - 그러나 NATURAL JOIN은 WHERE절 없으나, CROSS JOIN은 WHERE절에 JOIN조건 사용 가능 그러나 INNER JOIN과 같은 결과를 얻기 때문에 CROSS JOIN하는 의미가 없긴 함.
