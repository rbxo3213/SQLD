1. 데이터 모델링 3요소: Things, Attribute, relationship
2. 관계 체크사항: 관계 연결을 가능하게 하는 '동사'가 있느냐. not 명사
3. 논리 모델링 외래키는 물리 모델에서 반드시 구현되지는 않음.
4. 해시 조인: cpu연산이 큰 조인으로, 선행 테이블 크기가 작아야 유리, 인덱스 없어도 가능, only '=' 동등조인에서만
5. 설계 단계에서 데이터 모델의 성능을 고려하는 절차와 방법

   - 첫 번째 단계로 정규화를 적용한 DB모델 만들기, DB용량 산정, 트랜잭션 유형 파악, 이력모델, 기본키/외래키, 슈퍼타입/서브타입 조정

6. 데이터 모델링이 최종적으로 완료된 상태 즉 물리적 스키마 설계 직전단계는?

   - 논리적 데이터 모델링

7. COMMIT과 ROLLBACK의 장점: 데이터 무결성 보장, 영구적 변경 전 확인 가능, 논리적으로 연관된 작업을 그룹핑하여 처리 가능

8. UNION 연산자는 조회 결과에 대한 합집합을 나타내며 자동으로 정렬을 해준다 오 신기..

9. EQUI 조인은 반드시 기본키, 외래키 관계에 의해서만 성립되는 것은 아니다.

10. 여러 테이블로부터 원하는 데이터를 조회하기 위해서는 최소 전체 테이블 개수 N-1개 만큼의 조인이 필요하다

11. 상호 연관 서브쿼리는 서브 쿼리가 메인 쿼리의 행 마다 실행 -> 실행 속도가 상대적으로 떨어짐.

12. FROM 절에 아무리 많은 테이블이 나열되더라도 2개씩 조인됨.

13. COUNT(DISTINCT 이름) 이름 컬럼에서 중복 없이 고유한 값의 개수를 세어줍니다.

    - DISTINCT COUNT(이름) -> 여기서 DISTINCT는 아무 쓸모없이 쓰였ㅇㅁ.

14. CASE문 사용법..
    - CASE WHEN A.COL1 IS NULL THEN -1 ELSE 0 END
    - ✅ IS NULL은 NULL 여부를 정확히 판단할 수 있습니다.
      - CASE A.COL1 WHEN NULL THEN -1 ELSE 0 END
      - -- 단순 CASE에서 NULL은 비교가 안 됨 → ❌ 항상 ELSE로 처리됨
15. ORDER BY 절에서, 컬럼 3개에 대해서 내림차순 할 때.

    - 첫 번째 컬럼 내림차순 하고, 첫 번째 컬럼에서 같은 값을 두 번째 컬럼에서 내림차순 하고, 두 번째 컬럼에서 같은 값을 세 번째 컬럼에서 내림차순. 이렇게 함.!!!
      - 그니까 두 번째 컬럼 내림차순 정렬은, 첫 번째 컬럼에서 같았던 값을 가진 행에 대해서만 하면 되는 것!

16. LIKE '%이%' 처럼 양 옆에 %를 붙였을 경우 정상적인 인덱스 범위 스캔이 불가능하다.

17. 그룹 내 행 순서 관련 함수: FIRST_VALUE, LAST_VALUE, LAG, LEAD.

    - RANK는 순위를 구하는 윈도우 함수로 행의 순서와는 관련이 없다.
    - DENSE_RANK는 동일한 순위를 하나의 건수로 취급한다.

18. WHERE ROWNUM = 2 이런 건너뛰기는 안 되지만, WHERE ROWNUM=1 이건 건너뛰기 아니고 첫 행이라서 가능
19. SELECT COUNT(번호) FROM 사원 과 SELECT COUNT(번호) FROM 사원 WHERE 월급>=10000 OR 월급<10000

    - 월급이 NULL일 수 있기 때문에 두 쿼리의 결과는 항상 같지는 않음.

20. 날짜1 - 날짜2 의 결과는 일 수가 나온다
21. NEXT_DAY 함수는 지정된 요일의 첫 번째 날짜를 출력한다.
